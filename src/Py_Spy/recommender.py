import ast
from typing import Dict, List, Any, Optional

# Build an initial optimization rule library with detailed modification suggestions
OPTIMIZATION_RULES = {
    "loop_optimization": {
        "description": "Avoid unnecessary calculations inside loops. Move invariant calculations outside the loop.",
        "check": lambda node: isinstance(node, ast.For) or isinstance(node, ast.While),
        "suggestion": "If there are calculations that don't depend on the loop variable, move them outside the loop. For example, if you have a constant value calculation like 'result = 2 + 3' inside a loop, move it before the loop."
    },
    "redundant_calculation": {
        "description": "Avoid redundant calculations. If a value is calculated multiple times with the same input, consider caching it.",
        "check": lambda node: isinstance(node, ast.BinOp) and isinstance(getattr(node, 'parent', None), ast.For),
        "suggestion": "Identify calculations that are repeated with the same input. You can store the result of the first calculation in a variable and reuse it instead of recalculating. For example, if you have 'result = 2 + 3' multiple times, calculate it once and reuse the variable."
    },
    "cache_suggestion": {
        "description": "Consider using caching for functions with expensive calculations. You can use functools.lru_cache for simple cases.",
        "check": lambda node: isinstance(node, ast.FunctionDef),
        "suggestion": "If the function performs expensive calculations and the same input is likely to be used multiple times, you can use the 'functools.lru_cache' decorator. For example, add '@functools.lru_cache(maxsize=128)' above the function definition."
    },
    "function_call_optimization": {
        "description": "If a function is called frequently and has a high execution time, consider optimizing its implementation or reducing the number of calls.",
        "check": lambda func_stats: func_stats["total_time"] > 1 and func_stats["calls"] > 10,
        "suggestion": "Review the function implementation to see if there are any inefficiencies. You can also try to reduce the number of calls by caching intermediate results or refactoring the code to call the function less frequently."
    },
    "line_optimization": {
        "description": "Lines with high execution time or a large number of hits should be carefully examined. Look for inefficient algorithms or redundant operations.",
        "check": lambda line_stats: line_stats["percent_time"] > 50 or line_stats["hits"] > 100,
        "suggestion": "Analyze the code on this line to find inefficient algorithms or redundant operations. You may need to rewrite the code using more efficient data structures or algorithms. For example, if you are using a slow search algorithm, consider using a faster one like binary search if applicable."
    },
    "memory_optimization": {
        "description": "Functions with high memory usage may need optimization. Check for large data structures or memory leaks.",
        "check": lambda mem_stats: mem_stats["memory_usage"] > 100,
        "suggestion": "Review the function to identify large data structures that can be optimized. You can try to reduce the size of these data structures or release memory more quickly. Also, check for memory leaks by ensuring that all resources are properly released after use."
    }
}


class ASTVisitor(ast.NodeVisitor):
    def __init__(self):
        self.suggestions = []
        self.parent = None

    def generic_visit(self, node):
        # Set the parent node of the current node
        old_parent = self.parent
        self.parent = node
        for rule_name, rule in OPTIMIZATION_RULES.items():
            if rule_name in ["loop_optimization", "redundant_calculation", "cache_suggestion"] and rule["check"](node):
                self.suggestions.append({
                    "rule": rule_name,
                    "description": rule["description"],
                    "suggestion": rule["suggestion"],
                    "line": node.lineno if hasattr(node, 'lineno') else None
                })
        super().generic_visit(node)
        self.parent = old_parent


def generate_optimization_suggestions(code: str, analysis_results: Dict[str, Any]) -> List[Dict[str, Any]]:
    """
    Generate optimization suggestions
    :param code: The Python code to be analyzed
    :param analysis_results: Performance analysis results generated by the first set of code
    :return: List of optimization suggestions
    """
    suggestions = []
    try:
        # AST analysis
        tree = ast.parse(code)
        visitor = ASTVisitor()
        visitor.visit(tree)
        suggestions.extend(visitor.suggestions)

        # Generate suggestions based on function-level analysis results
        if "function" in analysis_results:
            func_results = analysis_results["function"]["results"]
            for func_stats in func_results:
                for rule_name, rule in OPTIMIZATION_RULES.items():
                    if rule_name == "function_call_optimization" and rule["check"](func_stats):
                        suggestions.append({
                            "rule": rule_name,
                            "description": rule["description"],
                            "suggestion": rule["suggestion"],
                            "function": func_stats["function"],
                            "line": func_stats["line_number"]
                        })

        # Generate suggestions based on line-by-line analysis results
        if "line" in analysis_results:
            line_results = analysis_results["line"]["results"]
            for line_stats in line_results:
                for rule_name, rule in OPTIMIZATION_RULES.items():
                    if rule_name == "line_optimization" and rule["check"](line_stats):
                        suggestions.append({
                            "rule": rule_name,
                            "description": rule["description"],
                            "suggestion": rule["suggestion"],
                            "line": line_stats["line_number"],
                            "function": line_stats["function"]
                        })

        # Generate suggestions based on memory analysis results
        if "memory" in analysis_results:
            mem_results = analysis_results["memory"]["results"]
            for mem_stats in mem_results:
                for rule_name, rule in OPTIMIZATION_RULES.items():
                    if rule_name == "memory_optimization" and rule["check"](mem_stats):
                        suggestions.append({
                            "rule": rule_name,
                            "description": rule["description"],
                            "suggestion": rule["suggestion"],
                            "function": mem_stats["function"]
                        })

    except SyntaxError as e:
        print(f"Syntax error in code: {e}")
    return suggestions
